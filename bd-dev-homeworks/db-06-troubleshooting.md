# Домашнее задание к занятию 6. `«Troubleshooting»` - `Швецов В.С.`

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

<details>

CRUD-операции в MongoDB относятся к основным операциям, которые можно выполнять с данными в базе данных MongoDB. Акроним CRUD означает: Create, Read, Update, Delete.

Чтобы остановки долгой операции можно выполнить следующие шаги:

- Выявление долгой операции:

Проверить журналы MongoDB или мониторинговые инструменты, чтобы убедиться, что запрос действительно занимает длительное время. Уточнить у пользователя, какая операция выполняется (create, read, update, delete), и на каком ресурсе (коллекция, база данных).


- Остановка запроса:

Воспользоваться методами мониторинга и управления MongoDB, такими как db.currentOp(), чтобы найти долгую операцию и прервать её. Выполнить следующие команды в оболочке MongoDB:

```sql
db.currentOp(true).inprog.forEach(function(op) {
    if (op.secs_running > 180) { // Если операция выполняется более 3 минут
        db.killOp(op.opid); // Прервать операцию
    }
});
```

Использовать административные инструменты MongoDB, такие как MongoDB Compass, для управления сеансами и запросами.

- Решение проблемы с долгими запросами:

MongoDB содержит профилировщик базы данных, который оценивает производительность каждой операции с базой данных. С помощью профилировщика мы можем определить запросы, которые выполняются медленнее, чем должны, и на основе этих данных определять, когда нам необходим индекс.

</details>

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?

<details>



Вероятно это связано с тем, что при масштабировании сервиса до N реплик увеличивается количество записанных ключей в Redis, а процесс истечения TTL не успевает за этими изменениями. Это приводит к тому, что увеличивается количество устаревших ключей, которые все еще остаются в базе данных Redis.

Поскольку механизм истечения TTL в Redis не является мгновенным, а происходит в фоновом режиме, при увеличении количества записанных ключей увеличивается и нагрузка на процесс истечения TTL. Это может привести к блокировке операций записи, так как Redis занят удалением устаревших ключей и не может эффективно обрабатывать новые записи.

Для решения этой проблемы можно принять следующие меры:

- Увеличить ресурсы сервера

- Оптимизировать TTL: Убедиться, что время жизни ключей настроено таким образом, чтобы они истекали вовремя и не накапливались в базе данных.

- Разделение базы данных: Рассмотреть возможность разделения базы данных Redis на более мелкие части или использование партиционирования, чтобы уменьшить нагрузку на процесс истечения TTL и улучшить производительность.

</details>

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения этой проблемы вы можете предложить?

<details>

Исходя из информации : Ошибка 2013 возникает, когда соединение между клиентом MySQL и сервером базы данных обрывается, обычно потому, что базе данных требуется слишком много времени для ответа.
Чаще всего данная ситуация возникает, когда происходит выборка очень большого количества данных, что очевидно, т.к. проблема стала возникать не сразу, а при росте количества записей.
Документация рекомендует нам увеличить настройку `net_read_timeout` , но делать это стоит только после того, как закончились пути оптимиация запроса с помощью индексов и других средств БД.

## Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили эту проблему?

<details>



Данная ошибка говорит о том, что закончилась выделенная память и она принудительного завершает выбранные запущенные процессы. 
Скорее всего, объем данных все еще велик.
Если нужен именно этот объем данных, то можно попробовать выгружать не все данные целиком, а пачками (batch) меньшего размера.

 Для решения проблемы можно настроить несколько параметров в конфигурационном файле postgresql.conf

- shared_buffers: Этот параметр определяет объем оперативной памяти, который PostgreSQL использует для кэширования данных. Увеличение этого параметра может улучшить производительность запросов, но также увеличит потребление памяти. Рекомендуется установить его в 25-30% от общего объема доступной памяти.

Пример: shared_buffers = 6GB

- work_mem: Этот параметр определяет объем оперативной памяти, выделенный для выполнения отдельных операций сортировки и хэширования. Увеличение этого параметра может ускорить выполнение сложных запросов, но также увеличит потребление памяти.

Пример: work_mem = 64MB

- maintenance_work_mem: Этот параметр определяет объем оперативной памяти, выделенный для операций обслуживания, таких как анализ и индексирование. Увеличение этого параметра может ускорить выполнение операций обслуживания, но также увеличит потребление памяти.

Пример: maintenance_work_mem = 4GB

- max_connections: Этот параметр определяет максимальное количество одновременных подключений к серверу PostgreSQL. Уменьшение этого параметра может сократить потребление памяти, если большое количество подключений создает нагрузку на память.

Пример: max_connections = 200

- effective_cache_size: Этот параметр позволяет PostgreSQL оценить доступное место в кэше операционной системы для кэширования данных. Установка этого параметра в правильное значение поможет оптимизировать запросы, использующие кэш файловой системы.

Пример: effective_cache_size = 16GB

</details>
